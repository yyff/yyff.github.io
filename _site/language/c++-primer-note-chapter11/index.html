<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>c++ primer读书笔记 第十一章 泛型算法 • c0ks'S TECH BLOG</title>
    <meta name="description" content="
  本系列文章是关于我的c++ primer读书笔记


">
    <meta name="keywords" content="">
    
    	<!-- Twitter Cards -->
	<meta name="twitter:title" content="c++ primer读书笔记 第十一章 泛型算法">
	<meta name="twitter:description" content="
  本系列文章是关于我的c++ primer读书笔记


">
	
	
	
	<meta name="twitter:card" content="summary">
	<meta name="twitter:image" content="http://localhost:4000/images/logo.jpg">
	
	<!-- Open Graph -->
	<meta property="og:locale" content="">
	<meta property="og:type" content="article">
	<meta property="og:title" content="c++ primer读书笔记 第十一章 泛型算法">
	<meta property="og:description" content="
  本系列文章是关于我的c++ primer读书笔记


">
	<meta property="og:url" content="http://localhost:4000/language/c++-primer-note-chapter11/">
	<meta property="og:site_name" content="c0ks'S TECH BLOG">

    <link rel="canonical" href="http://localhost:4000/language/c++-primer-note-chapter11/">

    <link href="http://localhost:4000/atom.xml" type="application/atom+xml" rel="alternate" title="c0ks'S TECH BLOG Atom Feed">
    <link href="http://localhost:4000/sitemap.xml" type="application/xml" rel="sitemap" title="Sitemap">

    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="cleartype" content="on">

    <link rel="stylesheet" href="http://localhost:4000/css/main.css">
    <!-- HTML5 Shiv and Media Query Support for IE -->
    <!--[if lt IE 9]>
      <script src="http://localhost:4000/js/vendor/html5shiv.min.js"></script>
      <script src="http://localhost:4000/js/vendor/respond.min.js"></script>
    <![endif]-->

  </head>

  <body id="js-body">
    <!--[if lt IE 9]><div class="upgrade notice-warning"><strong>Your browser is quite old!</strong> Why not <a href="http://whatbrowser.org/">upgrade to a newer one</a> to better enjoy this site?</div><![endif]-->

    <header id="masthead">
  <div class="inner-wrap">
    <a href="http://localhost:4000/" class="site-title">c0ks'S TECH BLOG</a>
    <nav role="navigation" class="menu top-menu">
        <ul class="menu-item">
	<li class="home"><a href="/">c0ks'S TECH BLOG</a></li>
	
    
    <li><a href="http://localhost:4000/" >Home</a></li>
  
    
    <li><a href="http://localhost:4000/language/" >Language</a></li>
  
    
    <li><a href="http://localhost:4000/linux/" >Linux</a></li>
  
    
    <li><a href="http://localhost:4000/algorithm/" >Algorithm</a></li>
  
    
    <li><a href="http://localhost:4000/about/" >About Me</a></li>
  
</ul>
    </nav>
  </div><!-- /.inner-wrap -->
</header><!-- /.masthead -->
    <nav role="navigation" id="js-menu" class="sliding-menu-content">
  <h5>c0ks'S TECH BLOG <span></span></h5>
  <ul class="menu-item">
    <li>
      <a href="http://localhost:4000/">
        
        <div class="title">Home</div>
        
      </a>
    </li><li>
      <a href="http://localhost:4000/language/">
        
        <div class="title">Language</div>
        
      </a>
    </li><li>
      <a href="http://localhost:4000/linux/">
        
        <div class="title">Linux</div>
        
      </a>
    </li><li>
      <a href="http://localhost:4000/algorithm/">
        
        <div class="title">Algorithm</div>
        
      </a>
    </li><li>
      <a href="http://localhost:4000/about/">
        
        <div class="title">About Me</div>
        
      </a>
    </li>
  </ul>
</nav>
<button type="button" id="js-menu-trigger" class="sliding-menu-button lines-button x2" role="button" aria-label="Toggle Navigation">
  <span class="nav-lines"></span>
</button>

<div id="js-menu-screen" class="menu-screen"></div>


    <div id="page-wrapper">
      <div id="main" role="main">
	<article class="wrap" itemscope itemtype="http://schema.org/Article">
		
		
  <nav class="breadcrumbs">
    <span itemscope itemtype="http://data-vocabulary.org/Breadcrumb">
      <a href="http://localhost:4000" itemprop="url">
        <span itemprop="title">Home</span>
      </a> › 
    <span itemscope itemtype="http://data-vocabulary.org/Breadcrumb">
      <a href="http://localhost:4000/language/" itemprop="url">
        <span itemprop="title">Language</span>
      </a>
    </span>
  </nav><!-- /.breadcrumbs -->

		<div class="page-title">
			<h1>c++ primer读书笔记 第十一章 泛型算法</h1>
		</div>
		<div class="inner-wrap">
			<div id="content" class="page-content" itemprop="articleBody">
				<blockquote>
  <h2 id="本系列文章是关于我的c-primer读书笔记">本系列文章是关于我的c++ primer读书笔记</h2>
</blockquote>

<p><strong>标准库没有给容器添加大量的功能函数，而是选择提供一组算法，这些算法大都不依赖特定的容器类型，是“泛型”的，可作用在不同类型的容器和不同类型的元素上</strong>。例如排序，或者查找某个特定的元素，或者查找最大或最小的元素，等等。</p>

<p><strong>大多数算法是通过遍历由两个迭代器标记的一段元素来实现其功能</strong>。典型情况下，算法在遍历一段元素范围时，操纵其中的每一个元素。算法通过迭代器访问元素，这些迭代器标记了要遍历的元素范围。</p>

<h2 id="概述">概述</h2>

<h3 id="算法如何工作">算法如何工作</h3>

<p><strong>每个泛型算法的实现都独立于单独的容器</strong>。这些算法还是大而不全的，并且不依赖于容器存储的元素类型。为了知道算法如何工作，让我们深入了解 <strong>find 操作。该操作的任务是在一个未排序的元素集合中查找特定的元素</strong>。
<strong>find是基于迭代器的,所以多种容器类型都可以使用</strong>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>vector&lt;int&gt;::const_iterator result = 
             find(vec.begin(), vec.end(), search_value);
 list&lt;int&gt;::const_iterator result = 
          find(lst.begin(), lst.end(), search_value);
</code></pre>
</div>

<p><strong>由于指针的行为与作用在内置数组上的迭代器一样，因此也可以使用 find 来搜索数组</strong>：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int ia[6] = {27, 210, 12, 47, 109, 83}; 
 int search_value = 83;
int *result = find(ia, ia + 6, search_value);
</code></pre>
</div>

<p>从概念上看，find 必须包含以下步骤：</p>
<ol>
  <li>顺序检查每个元素。</li>
  <li>如果当前元素等于要查找的值，那么返回指向该元素的迭代器。</li>
  <li>否则，检查下一个元素，重复步骤 2，直到找到这个值，或者检查完所有的元素为止。</li>
  <li>如果已经到达集合末尾，而且还未找到该值，则返回某个值，指明要查找的值在这个集合中不存在。</li>
</ol>

<h3 id="标准算法固有地独立于类型">标准算法固有地独立于类型</h3>

<p>find:这种算法只在一点上隐式地依赖元素类型：必须能够对元素做比较运算。
该算法的明确要求如下：</p>
<ol>
  <li>需要某种遍历集合的方式：能够从一个元素向前移到下一个元素。</li>
  <li>必须能够知道是否到达了集合的末尾。</li>
  <li>必须能够对容器中的每一个元素与被查找的元素进行比较。</li>
  <li>需要一个类型指出元素在容器中的位置，或者表示找不到该元素。</li>
</ol>

<h3 id="迭代器将算法和容器绑定起来">迭代器将算法和容器绑定起来</h3>

<p><strong>泛型算法用迭代器来解决第一个要求：遍历容器。所有迭代器都支持自增操作符，从一个元素定位下一个元素，并提供解引用操作符访问元素的值。</strong>
除了 第 11.3.5 节将介绍的一个例外情况之外，迭代器还支持相等和不等操作符，用于判断两个迭代是否相等。 
每个算法都需要使用（至少）两个迭代器指出该算法操纵的元素范围。第一个迭代器指向第一个元素，而第二个迭代器则指向最后一个元素的下一位置(超出末端迭代器或哨兵)。
<strong>用超出末端迭代器还可以很方便地处理第四个要求，只要以此迭代器为返回值，即可表示没有找到要查找的元素。</strong>
<strong>第三个要求——元素值的比较</strong>，有两种解决方法。默认情况下，find 操作要元素类型定义了相等（ == ）操作符，算法使用这个操作符比较元素。如果元素类型不支持相等（ == ）操作符，或者打算用不同的测试方法来比较元素，则可使用第二个版本的 find 函数。这个版本需要一个额外的参数：实现元素比较的函数名字。</p>

<h3 id="算法永不执行容器提供的操作">算法永不执行容器提供的操作</h3>

<p><strong>泛型算法本身从不执行容器操作，只是单独依赖迭代器和迭代器操作实现</strong>。算法基于迭代器及其操作实现，而并非基于容器操作。<strong>但本质上暗示了：使用“普通”的迭代器时，算法从不修改基础容器的大小</strong>。正如我们所看到的，算法也许会改变存储在容器中的元素的值，也许会在容器内移动元素，但是，算法从不直接添加或删除元素。</p>

<h2 id="初窥算法">初窥算法</h2>
<p>使用泛型算法必须包含 algorithm 头文件：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#include &lt;algorithm&gt;
</code></pre>
</div>

<p>标准库还定义了一组泛化的算术算法:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#include &lt;numeric&gt;
</code></pre>
</div>

<h3 id="只读算法">只读算法</h3>

<p>多算法只会读取其输入范围内的元素，而不会写这些元素。find 就是一个这样的算法。另一个简单的只读算法是 accumulate，该算法在 numeric 头文件中定义</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// sum the elements in vec starting the summation with the value 42 
     int sum = accumulate(vec.begin(), vec.end(), 42);
</code></pre>
</div>

<p>accumulate 带有三个形参。头两个形参指定要累加的元素范围。第三个形参则是累加的初值。
用于指定累加起始值的第三个实参是必要的，因为 accumulate 对将要累加的元素类型一无所知,这个事实有两层含义:首先，<strong>调用该函数时必须传递一个起始值</strong>，否则，accumulate 将不知道使用什么起始值。其次，<strong>容器内的元素类型必须与第三个实参的类型匹配，或者可转换为第三个实参的类型</strong>。在 accumulate 内部，第三个实参用作累加的起点；容器内的元素按顺序连续累加到总和之中。</p>

<p>考虑下面的例子，可以使用 accumulate 把 string 型的 vector 容器中的
元素连接起来：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// concatenate elements from v and store in sum 
     string sum = accumulate(v.begin(), v.end(), string(""));
</code></pre>
</div>

<p>注意：程序显式地创建了一个 string 对象，用该函数调用的第三个实参。传递一个字符串字面值，将会导致编译时错误。</p>

<h4 id="find_first_of--的使用">find_first_of  的使用</h4>

<p>这个算法带有两对迭代器参数来标记两段元素范围，在第一段范围内查找与第二段范围中任意元素匹配的元素，然后返回一个迭代器，指向第一个匹配的元素。<strong>如果找不到元素，则返回第一个范围的 end 迭代器</strong>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>list&lt;string&gt;::iterator it = roster1.begin();
it = find_first_of(it, roster1.end(), 
                  roster2.begin(), roster2.end());
</code></pre>
</div>

<h3 id="写容器元素的算法">写容器元素的算法</h3>

<h4 id="写入输入序列的元素">写入输入序列的元素</h4>

<p>写入到输入序列的算法本质上是安全的——只会写入与指定输入范围数量相同的元素。 
一个简单算法是 fill 函数:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>fill(vec.begin(), vec.end(), 0); // reset each element to 0 
     // set subsequence of the range to 10 
     fill(vec.begin(), vec.begin() + vec.size()/2, 10);
</code></pre>
</div>

<h4 id="不检查写入操作的算法">不检查写入操作的算法</h4>
<p>fill_n 函数带有的参数包括：一个迭代器、一个计数器以及一个值。该函数从迭代器指向的元素开始，将指定数量的元素设置为给定的值。
初学者常犯的错误的是：在没有元素的空容器上调用 fill_n 函数（或者类似的写元素算法）。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>vector&lt;int&gt; vec; // empty vector 
     // disaster: attempts to write to 10 (nonexistent) element s in vec 

     fill_n(vec.begin(), 10, 0);  对指定数目的元素做写入运算，或者写到目标迭代器的算法，都要检查目标的大小是否足以存储要写入的元素。
</code></pre>
</div>

<h4 id="引入-back_inserter">引入 back_inserter</h4>

<p><strong>确保算法有足够的元素存储输出数据的一种方法是使用插入迭代器</strong>。插入迭
代器是可以给基础容器添加元素的迭代器,<strong>用插入迭代器赋值时，则会在容器中添加一个新元素，其值等于赋值运算的右操作数的值。</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>back_insert_iterator&lt;Container&gt; back_inserter (Container&amp; x);
</code></pre>
</div>

<p>**back_inserter是一个函数,返回一个back_insert_iterator<Container>对象.**</Container></p>

<div class="highlighter-rouge"><pre class="highlight"><code>back_insert_iterator&lt;Container&gt;&amp; operator= (const typename Container::value_type&amp; value)
    { container-&gt;push_back(value); return *this; }
</code></pre>
</div>

<p><strong>back_insert_iterator重新定义了赋值运算符(=):调用push_back给容器尾部插入元素(即等号的右值).</strong>
使用 back_inserter 可以生成一个指向 fill_n 写入目标的迭代器：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    vector&lt;int&gt; vec;  
     fill_n (back_inserter(vec), 10, 0); // appends 10 elements to vec
</code></pre>
</div>

<p>现在，<strong>fill_n 函数每写入一个值，都会通过 back_inserter 生成的插入迭代器实现</strong>。效果相当于在 vec 上调用 push_back，在 vec 末尾添加 10 个元素，每个元素的值都是 0。</p>
<h4 id="写入到目标迭代器的算法">写入到目标迭代器的算法</h4>
<p>第三类算法向目标迭代器写入未知个数的元素。
copy 带有三个迭代器参数：<strong>头两个指定输入范围，第三个则指向目标序列的一个元素。</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>    //copy elements from ilst into ivec 
    vector&lt;int&gt; ivec; // empty vector 
    copy (ilst.begin(), ilst.end(), back_inserter(ivec));
</code></pre>
</div>

<h4 id="算法的-_copy--版本">算法的 _copy  版本</h4>

<p>有些算法提供所谓的“复制（copying）”版本。这些算法对输入序列的元素做出处理，但<strong>不修改原来的元素，而是创建一个新序列存储元素的处理结果</strong>。
replace 算法对输入序列做读写操作，将序列中特定的值替换为新的值。该算法带有四个形参：一对指定输入范围的迭代器和两个值。每一个等于第一值的元素替换成第二个值。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//replace any element with value of 0 by 42 
     replace(ilst.begin(), ilst.end(), 0, 42);
</code></pre>
</div>

<h3 id="对容器元素重新排序的算法">对容器元素重新排序的算法</h3>

<p>假设我们要分析一组儿童故事中所使用的单词。例如，可能想知道它们使用了多少个由六个或以上字母组成的单词。每个单词只统计一次，不考虑它出现的次数，也不考虑它是否在多个故事中出现。要求以长度的大小输出这些单词，对于同样长的单词，则以字典顺序输出。 
假定每本书的文本已经读入并保存在一个 string 类型的 vector 对象中，它的名字是words。现在，应该怎么解决包括统计单词出现次数这个问题呢？为了解此问题，要做下面几项操作：</p>
<ol>
  <li>去掉所有重复的单词。</li>
  <li>按单词的长度排序。</li>
  <li>统计长度等于或超过 6 个字符的单词个数。</li>
</ol>

<h4 id="去除重复">去除重复</h4>
<p>1排序</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// sort words alphabetically so we can find the duplicates 
     sort(words.begin(), words.end());
</code></pre>
</div>

<p>2去重复</p>

<div class="highlighter-rouge"><pre class="highlight"><code>        vector&lt;string&gt;::iterator end_unique = 
        unique(words.begin(), words.end());
        words.erase(end_unique, words.end());
        //用容器的erase函数删除重复
</code></pre>
</div>

<p>单词按次序排列后，现在的问题是：让故事中所用到的每个单词都只保留一个副本。<strong>unique 算法</strong>很适合用于解决这个问题，<strong>它带有两个指定元素范围的迭代器参数</strong>。 <strong>该算法删除相邻的重复元素，然后重新排列输入范围内的元素</strong>，并且<strong>返回一个迭代器，表示无重复的值范围的结束</strong>。</p>

<p><img src="http://img.blog.csdn.net/20150708220745340" alt="11" /></p>

<p>用 unique“删除”了相邻的重复值。给“删除”加上引号是因为 <strong>unique实际上并没有删除任何元素，而是将无重复的元素复制到序列的前端</strong>，从而覆盖相邻的重复元素。unique <strong>返回的迭代器指向超出无重复的元素范围末端的下一位置</strong>。</p>

<h4 id="使用容器操作删除元素">使用容器操作删除元素</h4>

<p>算法不直接修改容器的大小。如果需要添加或删除元素，则必须使用容器操作,在本例中调用 erase 实现该功能。</p>

<h4 id="定义需要的实用函数">定义需要的实用函数</h4>

<p>配套的实用函数，称为谓词。谓词是做某些检测的函数，返回用于条件判断的类型，指出条件是否成立。 
为了实现排序，必须定义一个谓词函数来实现两个 string对象的比较，并返回一个 bool 值，指出第一个字符串是否比第二个短：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// comparison function to be used to sort by word length 
     bool isShorter(const string &amp;s1, const string &amp;s2) 
     { 
         return s1.size() &lt; s2.size(); 
     }
</code></pre>
</div>

<p>另一个所需的谓词函数将判断给出的 string 对象的长度是否不小于 6：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  // determine whether a length of a given word is 6 or more 
     bool GT6(const string &amp;s) 
     { 
          return s.size() &gt;= 6; 
     }
</code></pre>
</div>

<h4 id="排序算法">排序算法</h4>

<p>标准库定义了四种不同的排序算法，上面只使用了最简单的 sort 算法，使 words 按字典次序排列。除了 sort 之外，标准库还定义了 stable_sort 算法，<strong>stable_sort 保留相等元素的原始相对位置</strong>。
sort 和 stable_sort 都是重载函数。其中一个版本使用元素类型提供的小
于（&lt;）操作符实现比较。
<strong>第二个重载版本带有第三个形参：比较元素所使用的谓词函数的名字</strong>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// sort words by size, but maintain alphabetic order for words of 
the same size 
     stable_sort(words.begin(), words.end(), isShorter);
</code></pre>
</div>

<h4 id="统计长度不小于-6-的单词">统计长度不小于 6 的单词</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>vector&lt;string&gt;::size_type wc = 
                  count_if(words.begin(), words.end(), GT6); 
</code></pre>
</div>

<p>执行 count_if 时，首先读取它的头两个实参所标记的范围内的元素。<strong>每读出一个元素，就将它传递给第三个实参表示的谓词函数</strong>。</p>

<h2 id="再谈迭代器">再谈迭代器</h2>
<p>C++ 语言还提供了另外三种迭代器：
•   <strong>插入迭代器</strong>：这类迭代器与容器绑定在一起，实现在容器中插入元素的功能。 
•   <strong>iostream 迭代器</strong>：这类迭代器可与输入或输出流绑定在一起，用于迭代遍历所关联的 IO 流。 
•   <strong>反向迭代器</strong>：这类迭代器实现向后遍历，而不是向前遍历。所有容器类型都定义了自己的 reverse_iterator 类型，由 rbegin 和 rend 成员函数返回。</p>

<h3 id="插入迭代器">插入迭代器</h3>
<p>C++ 语言提供了三种插入器，其差别在于插入元素的位置不同。
 •   back_inserter，创建使用 push_back 实现插入的迭代器。 
•   front_inserter，使用 push_front 实现插入。 
•   inserter，使用 insert 实现插入操作。除了所关联的容器外，inserter 
还带有第二实参：指向插入起始位置的迭代器</p>

<h4 id="front_inserter-需要使用-push_front">front_inserter 需要使用 push_front</h4>
<p>front_inserter 的操作类似于 back_inserter：该函数将<strong>创建一个迭代器，调用它所关联的基础容器的push_front 成员函数代替赋值操作。</strong></p>

<h4 id="inserter-将产生在指定位置实现插入的迭代器">inserter 将产生在<strong>指定位置实现插入</strong>的迭代器</h4>
<p>inserter 适配器提供更普通的插入形式。这种适配器带有<strong>两个实参</strong>：<strong>所关联的容器</strong>和<strong>指示起始插入位置的迭代器</strong>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code> list&lt;int&gt;::iterator it = 
            find (ilst.begin(), ilst.end(), 42); 
 replace_copy (ivec.begin(), ivec.end(), 
            inserter (ilst, it), 100, 0);
</code></pre>
</div>

<h4 id="iostream-迭代器">iostream 迭代器</h4>
<p>虽然 iostream 类型不是容器，但标准库同样提供了在 iostream 对象上使用的迭代器：istream_iterator 用于读取输入流，而 ostream_iterator 则用于写输出流（表11.1）。这些迭代器将它们所对应的流视为特定类型的元素序列。使用流迭代器时，可以用泛型算法从流对象中读数据（或将数据写到流对象中）。</p>

<p><img src="http://img.blog.csdn.net/20150708220841149" alt="这里写图片描述" /></p>

<p>流迭代器只定义了最基本的迭代器操作：自增、解引用和赋值。此外，可比较两个 istream 迭代器是否相等（或不等）。而 ostream 迭代器则不提供比较运算（表 11.2）。</p>

<p><img src="http://img.blog.csdn.net/20150708220901959" alt="这里写图片描述" /></p>

<p>流迭代器都是类模板：任何已定义输入操作符（» 操作符）的类型都可以定义istream_iterator。类似地，任何已定义输出操作符（« 操作符）的类型也可定义 ostream_iterator。 
在创建流迭代器时，必须指定迭代器所读写的对象类型：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    istream_iterator&lt;int&gt; cin_it(cin);    // reads ints1 from cin 
     istream_iterator&lt;int&gt; end_of_stream;  // end iterator value 
     // writes Sales_items from the ofstream named outfile 
     // each element is followed by a space 
     ofstream outfile; 
     ostream_iterator&lt;Sales_item&gt; output(outfile, " ");
</code></pre>
</div>

<p><strong>ostream_iterator 对象必须与特定的流绑定在一起</strong>。在创建 istream_iterator 时，可直接将它绑定到一个流上。<strong>另一种方法是在创建时不提供实参，则该迭代器指向超出末端位置</strong>。ostream_iterator 不提供超出末端迭代器。
在创建 ostream_iterator对象时，可提供<strong>第二个（可选的）实参，指定将元素写入输出流时使用的分隔符。分隔符必须是 C 风格字符串</strong>。因为它是 C 风格字符串，所以必须以空字符结束；否则，其行为将是未定义的。</p>

<h4 id="istream_iterator-对象上的操作">istream_iterator 对象上的操作</h4>

<p>构造与流绑定在一起的 istream_iterator 对象时将对迭代器定位，以便第一次对该迭代器进行解引用时即可从流中读取第一个值。
考虑下面例子，可使用 istream_iterator 对象将标准输入读到 vector 对象中。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>     istream_iterator&lt;int&gt; in_iter(cin); // read ints from cin 
     istream_iterator&lt;int&gt; eof; // istream "end" iterator 
     while (in_iter != eof) 
             vec.push_back(*in_iter++); 
</code></pre>
</div>

<p>其中 <strong>eof 迭代器定义为空的 istream_iterator 对象，用作结束迭代器</strong>。</p>

<p>更有趣的是可以这样重写程序：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>   istream_iterator&lt;int&gt; in_iter(cin); // read ints from cin 
     istream_iterator&lt;int&gt; eof;      // istream "end" iterator 
     vector&lt;int&gt; vec(in_iter, eof);  // construct vec from an iterator range
</code></pre>
</div>

<p>用一对标记元素范围的迭代器构造 vec 对象。这些迭代器是 istream_iterator 对象，这就意味着这段范围的元素是通过读取所关联的流来获得的。<strong>这个构造函数的效果是读 cin，直到到达文件结束或输入的不是 int 型数值为止</strong>。</p>

<h4 id="ostream_iterator-对象的使用">ostream_iterator 对象的使用</h4>
<p>可使用 ostream_iterator 对象将一个值序列写入流中:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>     ostream_iterator&lt;string&gt; out_iter(cout, "\n"); 
     istream_iterator&lt;string&gt; in_iter(cin), eof; 
     while (in_iter != eof) 
        *out_iter++ = *in_iter++; 
</code></pre>
</div>

<p><strong>这个程序读 cin，并将每个读入的值依次写到 cout 中不同的行中(因为ostream_iterator对象的构造函数使用了分隔符’\n’)。</strong></p>

<h4 id="在类类型上使用-istream_iterator">在类类型上使用 istream_iterator</h4>

<p><strong>提供了输入操作符（»）的任何类型都可以创建 istream_iterator 对象</strong>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>istream_iterator&lt;Sales_item&gt; item_iter(cin); 
</code></pre>
</div>

<h4 id="流迭代器的限制">流迭代器的限制</h4>
<p>•   不可能从 ostream_iterator 对象读入，也不可能写到 istream_iterator 对象中。 
•   <strong>一旦给 ostream_iterator对象赋了一个值，写入就提交了</strong>。赋值后，没有办法再改变这个值。此外，ostream_iterator 对象中每个不同的值都只能正好输出一次。 
•   <strong>ostream_iterator 没有 -&gt; 操作符</strong>。</p>

<h4 id="与算法一起使用流迭代器">与算法一起使用流迭代器</h4>

<p>算法是基于迭代器操作实现的的。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    istream_iterator&lt;int&gt; cin_it(cin);    // reads ints from cin 
     istream_iterator&lt;int&gt; end_of_stream;  // end iterator value 
     // initialize vec from the standard input: 
     vector&lt;int&gt; vec(cin_it, end_of_stream); 
     sort(vec.begin(), vec.end()); 
     
     ostream_iterator&lt;int&gt; output(cout, " "); 
     unique_copy(vec.begin(), vec.end(), output);
</code></pre>
</div>

<p>如果程序的输入是：</p>

<div class="highlighter-rouge"><pre class="highlight"><code> 23 109 45 89 6 34 12 90 34 23 56 23 8 89 23 
</code></pre>
</div>

<p>输出则是：</p>

<div class="highlighter-rouge"><pre class="highlight"><code> 6 8 12 23 34 45 56 89 90 109 
</code></pre>
</div>

<h3 id="反向迭代器">反向迭代器</h3>

<p>反向迭代器是一种反向遍历容器的迭代器。</p>

<p><img src="http://img.blog.csdn.net/20150708220929154" alt="这里写图片描述" /></p>

<h4 id="反向迭代器需要使用自减操作符">反向迭代器需要使用自减操作符</h4>

<p>标准容器上的迭代器既支持自增运算，也支持自减运算。但是，流迭代器却不然，由于不能反向遍历流，因此<strong>流迭代器不能创建反向迭代器</strong>。</p>

<h4 id="反向迭代器与其他迭代器之间的关系">反向迭代器与其他迭代器之间的关系</h4>

<p><strong>输出 line 中的第一个单词：</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>string::iterator comma = find(line.begin(), line.end(), ','); 
     cout &lt;&lt; string(line.begin(), comma) &lt;&lt; endl; 
</code></pre>
</div>

<p>如果在 line 中有一个逗号，则 comma 指向这个逗号；否则，comma 的值为 line.end()。</p>

<p><strong>输出列表中最后一个单词，可使用反向迭代器：</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>string::reverse_iterator rcomma = 
                        find(line.rbegin(), line.rend(), ',');
</code></pre>
</div>

<p><strong>直接尝试输出：</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>cout &lt;&lt; string(line.rbegin(), rcomma) &lt;&lt; endl;
</code></pre>
</div>

<p>会产生假的输出。例如，如果输入是：</p>

<div class="highlighter-rouge"><pre class="highlight"><code> FIRST,MIDDLE,LAST
</code></pre>
</div>

<p>则将输出 TSAL
使用反向迭代器时，以逆序从后向前处理 string 对象。为了得到正确的输出，必须<strong>将反向迭代器</strong> line.rbegin() 和 rcomma <strong>转换为从前向后移动的普通迭代器</strong>。<strong>只需调用所有反向迭代器类型都提供的成员函数 base 转换 rcomma 即可</strong>：</p>

<p><img src="http://img.blog.csdn.net/20150708220949289" alt="这里写图片描述" /></p>

<p>改为：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// ok: get a forward iterator and read to end of line 
     cout &lt;&lt; string(rcomma.base(), line.end()) &lt;&lt; endl;
</code></pre>
</div>

<h4 id="const-迭代器">const 迭代器</h4>
<p>在第 11.1 节使用 find 的程序中，我们将 result 定义为 <strong>const_iterator 类型</strong>。这样做是因为我们<strong>不希望使用这个迭代器来修改容器中的元素</strong>。
另一方面，虽然第 11.2.1 节的程序也不打算改变容器内的任何元素，但是<strong>它却使用了普通的非 const 迭代器来保存 find_first_of 的返回值</strong>。这两种处理存在细微的差别，值得解释一下。
算法要求用于指定范围的两个迭代器必须具有完全一样的类型。roster1.end() 返回的迭代器依赖于 roster1 的类型。如果该容器是 const 对象，则返回的迭代器是 const_iterator 类型；否则，就是普通的 iterator 类型。
原因是，<strong>在第二个例子中，程序将迭代器用作 find_first_of 的实参</strong>：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>find_first_of(it, roster1.end(), 
               roster2.begin(), roster2.end()) ;
</code></pre>
</div>

<p>该函数调用的输入范围由 it 和调用 roster1.end() 返回的迭代器指定。<strong>算法要求用于指定范围的两个迭代器必须具有完全一样的类型</strong>。roster1.end() 返回的迭代器依赖于 roster1 的类型。如果该容器是 const 对象，则返回的迭代器是 const_iterator 类型；否则，就是普通的 iterator 类型。在这个程序中，<strong>roster1 不是 const 对象，因而 end 返回的只是一个普通的迭代器。</strong></p>

<h4 id="五种迭代器">五种迭代器</h4>

<p>算法要求的迭代器操作分为五个类别:</p>

<p><img src="http://img.blog.csdn.net/20150708221021095" alt="这里写图片描述" /></p>

<ol>
  <li>输入迭代器 可用于读取容器中的元素
o  相等和不等操作符（==，!=），比较两个迭代器。 
o  前置和后置的自增运算（++），使迭代器向前递进指向下一个元素。 
o  用于<strong>读取元素的解引用操作符</strong>（<em>），<strong>此操作符只能出现在赋值运算的右操作数上</strong>。 
o  箭头操作符（-&gt;），这是 (</em>it).member 的同义语，也就是说，对迭代器进行解引用来获取其所关联的对象的成员</li>
  <li>输出迭代器
输出迭代器可用于向容器写入元素
o  前置和后置的自增运算（++），使迭代器向前递进指向下一个元素。
o  <strong>解引用操作符（*），只能出现在赋值运算的左操作数上</strong>。给解引用的输出迭代器赋值，将对该迭代器所指向的元素做写入操作。</li>
  <li>前向迭代器 用于读写指定的容器。这类迭代器只会以一个方向遍历序列。</li>
  <li>双向迭代器  从两个方向读写容器。需要使用双向迭代器的泛型算法包括 reverse。</li>
  <li>随机访问迭代器  提供在常量时间内访问容器任意位置的功能。
支持下面的操作：
o  关系操作符 &lt;、&lt;=、&gt; 和 &gt;=，比较两个迭代器的相对位置。 
o  迭代器与整型数值 n 之间的加法和减法操作符 +、+=、- 和 -=，结果是迭代器在容器中向前（或退回）n 个元素。 
o  两个迭代器之间的减法操作符（–），得到两个迭代器间的距离。 
o  下标操作符 iter[n]，这是 *(iter + n) 的同义词。
<strong>需要随机访问迭代器的泛型算法包括 sort 算法</strong>。vector、deque 和 string 迭代器是随机访问迭代器，用作访问内置数组元素的指针也是随机访问迭代器。</li>
</ol>

<p><strong>map、set 和 list 类型提供双向迭代器</strong>，而 <strong>string、vector 和 deque 容器上定义的迭代器都是随机访问迭代器都是随机访问迭代器</strong>，<strong>用作访问内置数组元素的指针也是随机访问迭代器</strong>。</p>

<h2 id="泛型算法的结构">泛型算法的结构</h2>

<h3 id="算法的命名规范">算法的命名规范</h3>

<p>第一种模式包括<strong>测试输入范围内元素的算法</strong>，第二种模式则<strong>应用于对输入范围内元素重新排序的算法</strong>。</p>

<h4 id="区别带有一个值或一个谓词函数参数的算法版本">区别带有一个值或一个谓词函数参数的算法版本</h4>

<p>很多算法通过检查其输入范围内的元素实现其功能。这些算法通常要用到标准关系操作符：== 或 &lt;。其中的大部分算法会提供第二个版本的函数，允许程序员提供比较或测试函数取代操作符的使用。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sort (beg, end);         // use &lt; operator to sort the elements 
     sort (beg, end, comp);   // use function named comp to sort the elements
</code></pre>
</div>

<h4 id="区别是否实现复制的算法版本">区别是否实现复制的算法版本</h4>

<p>无论算法是否检查它的元素值，都可能重新排列输入范围内的元素。在默认情况下，这些算法将重新排列的元素写回其输入范围。标准库也为这些算法提供另外命名的版本，<strong>将元素写到指定的输出目标</strong>。<strong>此版本的算法在名字中添加了 _copy 后缀</strong>：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>reverse(beg, end); 
reverse_copy(beg, end, dest);
</code></pre>
</div>

<h2 id="容器特有的算法">容器特有的算法</h2>

<p>list 容器上的迭代器是双向的，而不是随机访问类型，因此，在此容器上不能使用需要随机访问迭代器的算法。</p>

<p><img src="http://img.blog.csdn.net/20150708221114907" alt="这里写图片描述" /></p>

<p>list 容器特有的算法与其泛型算法版本之间有两个至关重要的差别。</p>

<p>其中一个差别是 <strong>remove 和 unique 的 list 版本</strong><strong>修改了其关联的基础容器</strong>：<strong>真正删除了指定的元素</strong>。</p>

<p>另一个差别是 list 容器提供的 <strong>merge 和 splice 运算会破坏它们的实参</strong>。使用 merge的泛型算法版本时，合并的序列将写入目标迭代器指向的对象，而它的两个输入序列保持不变。但是，使用 list 容器的 merge 成员函数时，则会破坏它的实参 list 对象——<strong>当实参对象的元素合并到调用merge 函数的 list 对象时，实参对象的元素被移出并删除</strong>。</p>

<h2 id="小结">小结</h2>

<p>C++ 标准化过程：创建和扩展了标准库。容器和算法库是标准库的基础。这些算法具有相同的结构。</p>

<p>算法与类型无关：它们通常在一个元素序列上操作，这些元素可以存储在标准库容器类型、内置数组甚至是生成的序列（例如读写流所生成的序列）上</p>

<p>代器可通过其所支持的操作来分类。标准库定义了五种迭代器类别：输入、输出、前向、双向和随机访问迭代器。</p>

<p>正如迭代器根据操作来分类一样，算法的迭代器形参也通过其所要求的迭代器操作来分类。只需要读取其序列的算法通常只要求输入迭代器的操作。而写目标迭代器的算法则通常只要求输出迭代器的操作，依此类推。</p>

				<hr />
				<footer class="page-footer">
					

<div class="author-image">
	<img src="http://localhost:4000/images/logo.jpg" alt="c0ks">
</div><!-- ./author-image -->
<div class="author-content">
	<h3 class="author-name" > <span itemprop="author">c0ks</span></h3>
	<p class="author-bio"></p>
</div><!-- ./author-content -->
					<div class="inline-btn">
	<a class="btn-social twitter" href="https://twitter.com/intent/tweet?text=c++%20primer读书笔记%20第十一章%20泛型算法&amp;url=http://localhost:4000/language/c++-primer-note-chapter11/&amp;via=" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i>  Twitter</a>
	<a class="btn-social facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/language/c++-primer-note-chapter11/" target="_blank"><i class="fa fa-facebook" aria-hidden="true"></i>  Facebook</a>
	<a class="btn-social google-plus"  href="https://plus.google.com/share?url=http://localhost:4000/language/c++-primer-note-chapter11/" target="_blank"><i class="fa fa-google-plus" aria-hidden="true"></i>  Google+</a>
</div><!-- /.share-this -->

					<div class="page-meta">
	<p> <time datetime="2015-12-18T00:00:00Z" itemprop="datePublished">December 18, 2015</time></p>
</div><!-- /.page-meta -->
				</footer><!-- /.footer -->
				<aside>
					
				</aside>
			</div><!-- /.content -->
		</div><!-- /.inner-wrap -->
		
	</article><!-- ./wrap -->
</div><!-- /#main -->

      <footer role="contentinfo" id="site-footer">
	<nav role="navigation" class="menu bottom-menu">
		<ul class="menu-item">
		
      
			<li><a href="http://localhost:4000" ></a></li>
		
		</ul>
	</nav><!-- /.bottom-menu -->
	<p class="copyright">&#169; 2016 <a href="http://localhost:4000">c0ks'S TECH BLOG</a> powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> + <a href="http://mmistakes.github.io/skinny-bones-jekyll/" rel="nofollow">Skinny Bones</a>.</p>
</footer>
    </div>

    <script src="http://localhost:4000/js/vendor/jquery-1.9.1.min.js"></script>
    <script src="http://localhost:4000/js/main.js"></script>

  </body>

</html>
