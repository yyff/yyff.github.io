---
layout: article
title:  "POJ 3669 Meteor Shower"
categories: algorithm
---

> 枚举, BFS


### 题意

陨石下落有一个时间点且上下左右四个方向都会被砸到，且陨石下落后的点不能走。Bessie需要从起点（0，0）开始走到一个不会被陨石砸到的地方，计算最小时间（步数）。

### 题解

1. 先给图中坐标的值初始化：若有陨石下落，则为陨石最早下落的时间；若无，则为无穷大。
2. 在BFS到达一个坐标的时候，若时间小于此坐标的值则将该坐标入队后继续搜索（此时若坐标值为无穷大，说明此点永远不会爆炸，即找到最小时间）。

### 代码

```cpp

#include <iostream>
#include <queue>
#include <cstdio>
#include <cstring>
#define MAXN 500
#define INF 1000000
using namespace std;

typedef struct
{
    int x;
    int y;
    int time;
}Point;
int direction[4][2]={
  {1,0},
  {-1,0},
  {0,1},
  {0,-1},
};
int mat[MAXN][MAXN];
int vis[MAXN][MAXN];
queue<Point> que;
int bfs()
{

    Point cur;
    cur.x = 0;
    cur.y = 0;
    cur.time = 0;
    vis[0][0] = 1;
    que.push(cur);
    while(!que.empty())
    {
        cur = que.front();
        que.pop();

        for(int i = 0; i < 4; i++)
        {
            Point temp;
            temp.x = cur.x + direction[i][0];
            temp.y = cur.y + direction[i][1];
            temp.time = cur.time + 1;
            if(temp.x >= 0 && temp.y >= 0 && temp.time < mat[temp.x][temp.y] && !vis[temp.x][temp.y] )
            {
                vis[temp.x][temp.y] = 1;
                if(mat[temp.x][temp.y] == INF)
                    return temp.time;

                que.push(temp);
            }

        }
    }
    return -1;

}
int main()
{
    int n;
    cin>>n;

    //memset(mat,INF,sizeof(mat));
    for(int i = 0;i < MAXN;i++)
        for(int j = 0; j < MAXN; j++)
        {
            mat[i][j]=INF;
        }
    memset(vis,0,sizeof(vis));
    for(int i = 0; i < n; i++)
    {
        int tempx;
        int tempy;
        int tempt;
        cin>>tempx>>tempy>>tempt;
        if(tempt < mat[tempx][tempy])
            mat[tempx][tempy] = tempt;
        for(int j = 0; j < 4; j++)
        {
            int dx = tempx + direction[j][0];
            int dy = tempy + direction[j][1];
            if(dx >= 0 && dy >=0)
                if(tempt < mat[dx][dy])
                    mat[dx][dy] = tempt;
        }
    }
    if(mat[0][0] == 0)
        cout<< -1 <<endl;
    else
        cout<< bfs() <<endl;
    return 0;
}

```