---
layout: article
title:  "POJ 2139"
categories: algorithm
---

> 图论-最短路径 （floyd算法，任意两点间的最短路径）

## 题意
奶牛之间的关系图，求一头奶牛到其他奶牛最短路径和 的最小值


## 题解
用floyd算法求图中任意两点之间的距离，枚举每个奶牛到其他奶牛的最短路径和，找到最小值。（d[u][v]表示边（u,v）的权值，不存在则是INF，d[i][i] = 0）

> floyd算法在《挑战程序设计竞赛》一书中的P103

## 代码

```c++
#include <iostream>
#include <cstring>
using namespace std;
const int MAXN = 1000;
const int INF = 10; //INF不能过大，会溢出
int d[MAXN][MAXN];
int n,m;
int result;
void floyd()
{
	for(int k = 1; k <= n; k++)
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
void solve()
{
	floyd();
	int mintemp = 10000000;
	for(int i = 1; i <= n; i++)
	{
		int sum = 0;
		for(int j = 1; j <= n; j++)
            if(i != j)
                sum += d[i][j];
		if(sum < mintemp)
			mintemp = sum;
	}
	result = mintemp;
}


int main()
{

    while(scanf("%d%d", &n, &m) != EOF)
    {
        memset(d, INF, sizeof(d));
        for(int i = 0; i <= n; i++)
            d[i][i] = 0;

        for(int i = 0;i < m; i++)
        {
            int num, a[1000];
            scanf("%d", &num);
            for(int j = 0;j < num; j++)
            {
                scanf("%d", &a[j]);
                for(int k = 0; k < j; k++)
                    d[a[j]][a[k]] = d[a[k]][a[j]] = 1;
            }
        }
        solve();
        cout << result * 100 / (n-1) << endl;
	}
	return 0;
}

```