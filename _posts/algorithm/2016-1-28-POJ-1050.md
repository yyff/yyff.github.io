---
layout: article
title:  "POJ 1050"
categories: algorithm
---

> 动态规划

## 题意
求最大子矩阵和（动态规划问题最大子序列和的变种）

## 题解
枚举所有子矩阵的开始行i1和结束行i2，那么当前子矩阵第j列的和b[j] = a[i1][j] + a[i1 + 1][j] +... a[i2][j]，此时最大子矩阵和就变成求一维数组b的最大子序列和。


## 代码
```c++
#include <iostream>
#include <string>
#include <stack>
#include <queue>
#include <vector>
#include <set>
#include <map>
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <ctype.h>
using namespace std;
int n;
int a[101][101];
int b[101];

void solve()
{

    while(scanf("%d", &n) != EOF)
    {
        int result = 0;
        for(int i = 0; i < n; i++)
            for(int j = 0; j < n; j++)
                scanf("%d", &a[i][j]);

        for(int i1 = 0; i1 < n; i1++)
        {
            for(int i2 = i1; i2 < n; i2++)
            {
                memset(b, 0, sizeof(b));
                for(int j = 0; j < n; j++)
                {
                    for(int k = i1; k <= i2; k++)
                    {
                        b[j] += a[k][j];
                    }
                }
                int maxsum = 0;
                int sum = 0;
                for(int i = 0; i < n; i++) //求当前最大子序列和
                {
                    sum += b[i];
                    if(sum < 0)
                        sum = b[i];
                    if(sum > maxsum)
                        maxsum = sum;

                }
                if(maxsum > result)
                    result = maxsum;


            }
        }
        printf("%d\n", result);
    }
}

int main()
{
    solve();

}

```