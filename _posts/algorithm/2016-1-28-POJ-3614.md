---
layout: article
title:  "POJ 3614"
categories: algorithm
---

> 优先队列

## 题意
每个奶牛有一个防晒指数区间[minSPF,maxSPF],每个防晒霜有一个防晒指数SPF和其能使用的奶牛数目。求防晒霜能覆盖的最大奶牛数


## 题解
1. 将奶牛按最小防晒指数升序排序，防晒霜按SPF升序排序。
2. 对每瓶已按升序排好的防晒霜，将满足（SPF > minSPF）的奶牛 的maxSPF入优先队列。优先队列的队头是队中所有奶牛maxSPF的最小值。
3. 若当前防晒霜的SPF < maxSPF,则更新结果;否则如果 SPF > maxSPF，则直接出队（因为后面防晒霜的SPF > 当前防晒霜SPF > maxSPF)

## 代码



```c++
#include <iostream>
#include <queue>
#include <vector>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 10001;

typedef pair<int,int> Pair;
Pair cow[MAXN];
Pair bottle[MAXN];
priority_queue<int, vector<int>, greater<int> > pq;
int C,L;
int result;

void solve()
{
	result = 0;
	int j = 0;
	for(int i = 0; i < L; i++)
	{
		while(j < C &&  bottle[i].first >= cow[j].first)
		{
			pq.push(cow[j].second);
			j++;
		}
		while(!pq.empty() && bottle[i].second)
		{
			int x = pq.top();
			pq.pop();
			if(bottle[i].first > x)     //min bottle's SPF > cow's maxSPF, the cow can't be used
				continue;
			bottle[i].second--;
			result++;
		}
	}
}
int main()
{
	cin >> C >> L;
	for(int i = 0; i < C; i++)
		cin >> cow[i].first >> cow[i].second;
	for(int i = 0; i < L; i++)
		cin >> bottle[i].first >> bottle[i].second;
	sort(cow, cow + C);
	sort(bottle, bottle + L);
	solve();
	cout << result <<endl;

	return 0;
}
```