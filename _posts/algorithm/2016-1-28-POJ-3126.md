---
layout: article
title:  "POJ 3126"
categories: algorithm
---

> 数论（素数-埃氏筛法） BFS


## 题意
给两个4位的素数作为原始和目标素数，从原始素数开始，每次只能变动一位且变动后仍是素数，直到最后变成目标素数。求最小的变动次数，无法变成则输出0


## 题解
使用BFS解决。
1. 一个数在一次变化中，4个位每位都有10种可能（0--9），一共是40种，将变化后仍是素数的数入队。
2. 素数用埃氏筛法判定

## 代码

```c++
#include <iostream>
#include <queue>
#include <cstring>
using namespace std;
const int MAXN = 10000 + 128;
bool isprime[MAXN];
bool vis[MAXN];
int step[MAXN];
int T, from, to;

int prim[MAXN]; //素数集合,prim[i]为第i个素数
int sieve(int n) //返回<=n的素数个数
{

    int index = 0;
    isprime[0] = isprime[1] = false;
    fill(isprime, isprime + MAXN, true);

    for(int i = 2; i < n; i++)  
    {
        if(isprime[i])
        {
            prim[index++] = i;
            for(int j = 2 * i; j < n; j += i) //删除素数i的倍数
                isprime[j] = false;
        }

    }
    return index;
}
int change(int n, int pos, int i) //改变n的第pos位为i
{
    switch(pos)
    {
        case 0: 	//个位
            return n / 10 * 10 + i;
        case 1:
            return n / 100 * 100 + n % 10 + i * 10;
        case 2:
            return n / 1000 * 1000 + n % 100 + i * 100;
        case 3:
            return n % 1000 + i * 1000;
    }
}

int BFS()
{
    memset(step, 0, sizeof(step));
    fill(vis, vis + MAXN, false);
    queue<int> q;
    q.push(from);
    vis[from] = true;
    step[from] = 0;

    while(!q.empty())
    {
        int x = q.front();
        q.pop();
        if(x == to) //变化成目标素数，返回步数
            return step[x];
        for(int pos = 0; pos < 4; pos++) //4位
        {
            for(int i = 0; i <= 9; i++) // 每位可能为0..9
            {
                if(pos == 3 && i == 0)
                    continue;
                int temp = change(x, pos, i);
                if(!vis[temp] && isprime[temp])
                {
                    q.push(temp);
                    step[temp] = step[x] + 1; //
                    vis[temp] = true;
                }

            }
        }
    }
    return 0;

}
int main()
{
    cin >> T;
    sieve(MAXN - 1);
    while(T--)
    {

        cin >> from >> to;
        cout << BFS() << endl;

    }

    return 0;
}

```