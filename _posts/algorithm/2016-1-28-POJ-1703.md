---
layout: article
title:  "POJ 1703"
categories: algorithm
---

> 并查集（具体类别未知的划分）

## 题意
一个城市里有两个帮派，
1. （A [a] [b] ）为已知信息，表示a和b属于不同帮派，但不知a和b具体属于哪个帮派。
2. （D [a] [b] ）判断a和b是否属于一个帮派或未知。


## 题解
使用和挑战程序设计竞赛书中P89类似的并查集(58行处使用cin输入会导致超时)。

1. 匪徒人数为N，帮派数为2。则给每个人i创建2个元素i-A（用i表示）和i-B（用i+N表示）,即一个长度为2*N的一维数组。（i-A表示i属于帮派A）
2. 每个并查集中的元素表示集合内元素代表的情况要么同时发生，要么都不发生。
3. i和j属于同一类则操作： unite(i, j)和unite(i+N, j+N),表示ij要么都属于A，要么都属于B
4. i和j不属于同一类则操作  ：  unite(i, j+N)和unite(i+N, j)
5. 判断i和j属于同一类等价于判断same(i,j)或same(i+N, j+N)是否成立
6. 不同类则判断same(i, j + N)或same(j, i + N)是否成立

## 代码

```c++
#include <iostream>
using namespace std;

const int MAXN = 100000 * 2 + 64;
int parent[MAXN];
int height[MAXN];
void init(int n)
{
	for(int i = 0; i < n; i++)
	{
		parent[i] = i;
		height[i] = 0;
	}
}
int find(const int& x)
{
	if (parent[x] == x)
		return x;
	else
		return parent[x] = find(parent[x]);
}
void unite(int x, int y)
{
	x = find(x);
	y = find(y);
	if(x == y)
		return ;
	if(height[x] < height[y])
		parent[x] = y;
	else if(height[x] == height[y])
	{
		parent[y] = x;
		height[x]++;
	}
	else
		parent[y] = x;
}
bool same(int x, int y)
{
	return find(x) == find(y);
}

int main()
{
    int T;
    int N,M;
	cin >> T;
	while (T--)
	{
		int N, M;
		cin >> N >> M;
		init(N * 2);
		getchar();
		while (M--)
		{
            char temp;
            int x, y;
			scanf("%c%d%d", &temp, &x, &y);  //这里用cin会超时
			getchar();
			switch(temp)
			{
				case 'D':
					unite(x, y + N);
					unite(y, x + N);
					break;
				case 'A':
					if(same(x, y))
						cout << "In the same gang." <<endl;
					else if(!same(x, y) && same(x, y + N))
						cout << "In different gangs." <<endl;
					else
						cout <<  "Not sure yet." <<endl;
					break;
			}
		}
	}
	return 0;
}


```