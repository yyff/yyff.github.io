---
layout: article
title:  "POJ 3176 Cow Bowling"
categories: algorithm
---

> 动态规划



### 题意

扔保龄球，若扔中第i层的第j个瓶子，则只能撞到第i+1层的两个相邻的瓶子（j和j+1），每个瓶子有权值，求每层扔中一个瓶子后的最大权值


### 题解

用动态规划解决。状态转移方程为:

> dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) + bowl[i][j]; (j-1 >= 0)

> dp[i][j] = dp[i-1][j] + bowl[i][j]; (j-1 < 0)



### 代码
```cpp
#include <iostream>
using namespace std;
const int MAXN = 1000;
int bowl[MAXN][MAXN];
int dp[MAXN][MAXN];
int N;
int result;
void solve()
{
	dp[0][0] = bowl[0][0];
	for(int i = 1; i < N; i++)
	{
		for(int j = 0;j <= i; j++)
		{
			if(j - 1 >= 0)
				dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) + bowl[i][j];
			else
				dp[i][j] = dp[i-1][j] + bowl[i][j];
		}
	}
	int maxtemp = -1;
	for(int i = 0; i < N; i++)
	{
		if(dp[N-1][i] > maxtemp)
			maxtemp = dp[N-1][i];
	}
	result = maxtemp;

}
int main()
{
	cin>>N;
	for(int i = 0; i < N; i++)
	{
		for(int j = 0; j <= i; j++)
		{
			cin>>bowl[i][j];
		}
	}
	solve();
	cout<< result <<endl;
	return 0;
}
```
