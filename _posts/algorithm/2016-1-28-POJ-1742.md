---
layout: article
title:  "POJ 1742"
categories: algorithm
---

> 动态规划（男人8题系列）

### 题意
多枚不同面值的硬币，问能形成的面值数。


### 题解
和挑战程序设计书中的多重部分和（P63）问题相似，用动态规划解决，AC代码看第三段。

**1. 未优化，将重复的硬币展开后放一个一维数组中，即将它们当不同的硬币来考虑。这样导致内存超出或者超时**

> dp[i][j]等于1表示前i枚硬币可以形成价值j，0表示不能形成
```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int MAXN = 1001;
const int MAXVAL = 1001;

int dp[MAXN][MAXVAL];
int val[MAXN];
int num[MAXN];
int coins[MAXN];
int n,m;
int amount;
int result;
void solve()
{
    memset(dp, 0, sizeof(dp));
	result = 0;
    dp[1][val[0]] = 1;
    for(int i = 0; i <= amount; i++)  //init the dp[i][0] = 1;
    {
        dp[i][0] = 1;
    }
	for(int i = 2; i <= amount; i++)
	{
		for(int j = 0; j <= m; j++)
		{
			if(j - coins[i] >= 0 && dp[i-1][j-coins[i]] == 1) //需要第i枚硬币形成价值j
                dp[i][j] = 1;
			if(dp[i-1][j] == 1)  //不需要第i枚硬币就可以形成价值j
				dp[i][j] = 1;
		}
	}

    for(int i  = 1; i <= m; i++)
    {
        if(dp[amount][i] == 1)
            result++;
    }


}
int main()
{
	while(cin >> n >> m && (n != 0 && m != 0))
	{
		for(int i = 0; i < n; i++)
			cin >> val[i];
        amount = 0;
		for(int i = 0; i < n; i++)
		{
			cin >> num[i];
			amount += num[i];
		}
		int k = 1;
		for(int i = 0; i < n; i++)  //unfold the coins, index start with 1 
		{
			for(int j = 0; j < num[i]; j++) 
				coins[k++] = val[i]; 
		}
		solve();
		cout << result << endl;
	}
	return 0;
}


```

**2.通过用循环次数表示此次加入的硬币i，可以优化成一维数组的dp，但还是导致超时。**

注意：需要从价值m往前更新数组，这样可以使得此次循环(表示第i枚硬币)用的是上次循环（第i-1枚硬币）更新后的数组
```c++

#include <iostream>
#include <cstring>
using namespace std;
const int MAXN = 100006;

int dp[MAXN];
int val[MAXN];
int num[MAXN];
int coins[MAXN];
int n,m;
int amount;
int result;
void solve()
{
    memset(dp, 0, sizeof(dp));
	result = 0;
    dp[0] = 1;
	for(int i = 1; i <= amount; i++)
	{
		for(int j = m; j >= coins[i]; j--)
		{

            if(!dp[j] && dp[j-coins[i]] )
            {
                dp[j] = 1;
                result++;
            }

		}
	}

}
int main()
{
	while(cin >> n >> m && (n != 0 && m != 0))
	{
		for(int i = 0; i < n; i++)
			cin >> val[i];
        amount = 0;
		for(int i = 0; i < n; i++)
		{
			cin >> num[i];
			amount += num[i];
		}
		int k = 1;
		for(int i = 0; i < n; i++)
		{
			for(int j = 0; j < num[i]; j++)
				coins[k++] = val[i];
		}
		solve();
		cout << result << endl;
	}
	return 0;
}

```

**3.dp数组的值只用来表示能不能形成价值j，有些浪费。**

优化成： -1表示不能形成价值j，大于等于0时表示形成价值j后第i件物品的剩余数量


```c++
#include <iostream>
#include <cstring>
using namespace std;
const int MAXN = 100006;

int dp[MAXN];
int val[MAXN];
int num[MAXN];
int n,m;
int result;
void solve()
{
    memset(dp, -1, sizeof(dp));
	result = 0;
    dp[0] = 0; 			//保证第一次循环时第一枚硬币能被更新
	for(int i = 0; i < n; i++)
	{
		for(int j = 0; j <= m; j--)
		{

			if(dp[j] >= 0) //每个循环开始，都会有dp[0] = num[i]; 
				dp[j] = num[i];
			else if(j - val[i] < 0 || dp[j - val[i]] <= 0) // 第i枚硬币价值超过j或者数量不够时，更新为失败值-1
				dp[j] = -1;
            else
                dp[j] = dp[j - val[i]] - 1;
		}
	}
	for(int i = 1; i <= m; i++)  
		if(dp[i] >= 0)  //大于等于0的值表示可以形成价值i
			result++;

}
int main()
{
	while(cin >> n >> m && (n != 0 && m != 0))
	{
		for(int i = 0; i < n; i++)
			cin >> val[i];
		for(int i = 0; i < n; i++)
			cin >> num[i];
		solve();
		cout << result << endl;
	}
	return 0;
}
```